-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parcodegen where
import Abscodegen
import Lexcodegen
import ErrM
}

%name pWidgetType WidgetType
%name pListParameter ListParameter
%name pParameter Parameter
%name pNum Num
%name pListDItem ListDItem
%name pDKey DKey
%name pDValue DValue
%name pDItem DItem
%name pDictionary Dictionary
%name pArray Array
%name pListObject ListObject
%name pObject Object
%name pWidgetParams WidgetParams
%name pWidget Widget

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 'Ext.Button' { PT _ (TS "Ext.Button") }
 ',' { PT _ (TS ",") }
 '.' { PT _ (TS ".") }
 ':' { PT _ (TS ":") }
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 'new' { PT _ (TS "new") }

L_integ  { PT _ (TI $$) }
L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read $1) :: Integer }
Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted { $1 }

WidgetType :: { WidgetType }
WidgetType : 'Ext.Button' { Button } 


ListParameter :: { [Parameter] }
ListParameter : {- empty -} { [] } 
  | ListParameter Parameter ',' { flip (:) $1 $2 }


Parameter :: { Parameter }
Parameter : Object { Param $1 } 


Num :: { Num }
Num : Integer '.' Integer { NumDouble $1 $3 } 
  | Integer { NumInteger $1 }


ListDItem :: { [DItem] }
ListDItem : {- empty -} { [] } 
  | ListDItem DItem ',' { flip (:) $1 $2 }


DKey :: { DKey }
DKey : Ident { DictKeyIdent $1 } 
  | String { DictKeyString $1 }


DValue :: { DValue }
DValue : Object { DictValue $1 } 


DItem :: { DItem }
DItem : DKey ':' DValue { DictItem $1 $3 } 


Dictionary :: { Dictionary }
Dictionary : '{' ListDItem '}' { Dict (reverse $2) } 


Array :: { Array }
Array : '[' ListObject ']' { Arr (reverse $2) } 


ListObject :: { [Object] }
ListObject : {- empty -} { [] } 
  | ListObject Object ',' { flip (:) $1 $2 }


Object :: { Object }
Object : Ident { ObjIdent $1 } 
  | String { ObjString $1 }
  | Num { ObjNumb $1 }
  | Dictionary { ObjDictionary $1 }
  | Array { ObjArray $1 }


WidgetParams :: { WidgetParams }
WidgetParams : ListParameter ',' Dictionary { WParams (reverse $1) $3 } 
  | Dictionary { WNoParams $1 }


Widget :: { Widget }
Widget : 'new' WidgetType '(' WidgetParams ')' { NewWidget $2 $4 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map prToken (take 4 ts))

myLexer = tokens
}

