trip = lambda a b c . { a, b, c } ;

hundred = 
    let { x, y, z } = trip 2 40 20 in 
    (x * y) + z ;

nil = {} ;

cons = lambda e lst . { e, lst } ;

head = lambda lst .
    let { h, t } = lst in
    h ;

tail = lambda lst .
    let { h, t } = lst in
    t ;

map = lambda f lst .
    if lst == nil // forces evaluation of lst, meaning non-termination for infinite lists
        then nil
        else let {h,t} = lst in (cons (f h) (map f t)) ;

or = lambda a b . if a then true else b ;

naturals =
    letrec nats = lambda n . cons n (nats (n + 1)) in
    nats 1 ;

evens = map (lambda n . n * 2) naturals ;

take =
    letrec tak = lambda n lst .
        if n == 1
            then cons (head lst) nil
            else cons (head lst) (tak ( n - 1 ) (tail lst))
    in tak ;

len = letrec len_ = lambda lst .
    if lst == {}
        then 0
        else 1 + len_ (tail lst)
    in len_ ;

foldr =
    letrec zw = lambda f init lst .
        if lst == nil
            then init
            else f (head lst) (zw f init (tail lst))
    in zw ;

foldl =
    letrec fl = lambda f init lst .
        if lst == nil
            then init
            else let { h, t } = lst in
                (fl f (f init h)) t
    in fl;


sum = foldl (lambda x y . x + y) 0 ;
product = foldl (lambda x y . x * y) 1 ;
fact = lambda n . product (take n naturals) ;

fastfact = 
    letrec f = lambda n . if n == 1 then 1 else n * f (n - 1) in
    f ;

// main is executed by qlcr
main = fastfact 10000
    ;
